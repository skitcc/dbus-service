# DBUS Configuration Manager

## Зависимости
- c++20 или выше
- sdbus-c++
- boost
- meson build
- ninja

## Сборка проекта 
1. ``` sudo apt-get install build-essential meson ninja-build libboost-all-dev libsdbus-c++-dev cmake g++ pkg-config```

Если хотите расширять проект(об этом подробнее ниже) стоит склонить официальный репозиторий sdbus-c++


``` $ git clone https://github.com/Kistler-Group/sdbus-cpp.git ```

затем выполнить следующие шаги

``` $  cd sdbus-cpp```

``` $ cd build ```

``` $  cmake.. -DSDBUSCPP_BUILD_CODEGEN=ON ```

``` $ make ```

```$ sudo make install ```


в результате чего вам будет доступна утилита **sdbus-c++-xml2cpp**


2. После установки всех необходимых зависимостей следует склонировать текущий репозиторий

``` $ git clone https://github.com/skitcc/dbus-service.git ```

затем 

``` $ cd dbus-service ```

``` $ meson setup build ```

``` $ cd build && meson compile```


В результате этих действий в папке build окажутся два исполняемых файла.
1. daemon.exe - сервер, который при запуске регестрирует сервис на dbus шине и подключает к нему столько dbus обьектов столько находится конфигураций (об этом чуть позже) в папке ~/data/
2. client.exe - приложение, которое реализует заданное поведение для каждого созданного обьекта


## Пример работы программы

Для наглядности созданим в папке ~/data единственную конфигурацию, назовем ее **timeout.conf** и содержать этот файл будет следующее

```
--META--
Timeout
--------
Timeout int:2
TimeoutPhrase string:mama
```

Секция которая начинается с заголовка *--META--* и заканчивается тире называется секции метаданных, этой секцией должна обладать любая конфигурация. Тело секции метаданных содержит слово **Timeout** - оно означает что будет будет создан обычный обьект, но его поведение будет характерно поведению описанному в задании (вывод TimeoutPhrase каждые Timeout секунд), сделано это для того что если вдруг вы решите расширить сервис какими нибудь другими интерфейсами или, предположим, задать другое поведение для другого типа обьектов (например вычисление следующего числа фибоначчи каждые timeout секунд или что то подобное), то вы совершенно спокойно придумываете новый тип семейства Fibonacci, создаете (или нет) новый интерфейс, наследуете от него через ProxyInterfaces прокси адаптер и затем наследуетесь от BaseProxy реализуя чисто виртуальную функцию 


```     virtual void specificBehaviour() = 0; ```